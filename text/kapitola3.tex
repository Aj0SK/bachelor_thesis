\chapter{Towards Building a Squiggle Index}

\label{kap:methAdjust} % id kapitoly pre prikaz ref

In this chapter, we look at how we can use our discretization algorithm and findings
from the previous chapter to reach our goal of selective sequencing.

\section{Index idea}

We can transform the reference DNA sequence to signal using our simulation
process, choose the size of the window - $w$, create the level string of the reference.
Then, when the real signal from the squiggle arrives, we will perform the same process
as with the simulated reference signal. Now we have one reference level string and
one which we want to find in it. We see that this can be better formulated as an
algorithmic problem. However, there is a minimal probability that the level string
of the longer squiggle would match precisely to some area in the reference level string.
Instead of looking for the exact match in the reference, we will cut the reference
level string into overlapping subsequences of length $k$ and put them into a hash table.
Hash table is a data structure that allows insertion and search of an element in
amortized time complexity $O(1)$. When we have this hash table ready after the
preprocessing, we can start with the actual squiggle processing. For every squiggle, we will
build the level string. Then, we will cut it into the overlapping
subsequences of the same length $k$ and see how many of them can be found in our
prepared hashtable. We call all the subsequences from our query squiggle that are
present in the hash table \textit{hits}. Our initial assumption is that the number
of hits will be considerably higher for the squiggle that belongs to the reference.

The important thing is that we need to use only the shortest part of the squiggle
possible and also use only data from the beginning of the squiggle. Before tackling
this way harder problem, we will look at easier task. We would want to see how
our discretization works and how similar are two-level strings of reference and
the real signal that corresponds to this reference. For this purpose, we will try to
find our query level string in the reference level string.

\section{Aligning the squiggle level string}
\label{section:alignMinimap}

We already know that it does not make sense to look for the exact match of the query string in the reference
so we will need some string searching technique that can deal with few errors.
Our alignment algorithm presented in Section \ref{section:alignment} could be adapted but it lacks the neccessary speed. This
algorithm works in the time complexity $O(r\cdot s)$ where $r$ is the length of the
reference sequence and $q$ is the length of the query string. Many algorithms are able
to do this fast and with very high accuracy. We decided to tweak a Minimap2 \cite{li2018minimap2} algorithm. This is
one of the most popular DNA sequence aligning algorithms. This algorithm can take the
query DNA sequence and find it in a long reference DNA sequence. It is also able to
find the query DNA string even if it does not exactly match any subsequence precisely.
Hovewer, this algorithm works only with the DNA sequences. What we will do is that we choose
the number of levels $w=4$. This will cause that the reference and query level strings will both consist of
the characters 'a', 'b', 'c', 'd'. We then substitute 'a', 'b', 'c', 'd' by
'A', 'C', 'G', 'T' subsequently. We now obtained the manipulated level strings that
are represented using the DNA sequences. Now, we can use the Minimap2 algorithm for
finding our manipulated query level string in the manipulated reference level string.
As the Minimap2 is most of the time used and also optimized to perform well on DNA
sequences, we need to be careful of some catches that come with using it for this
purpose. For example, we need to ignore the hits on the reverse strand as the
reverse strand does not carry the same information as in the real DNA sequence.
This also speeds up the whole algorithm considerably.

We now take the level string of the relatively big part of the squiggle. We take the
fixed part of the squiggle from the $5\,000$th readout to the $60\,000$th. Of the 50
tested squiggles, all of them were correctly aligned to the correct contig and also
correct position. This was a very promising result, so we decided to optimize a
Minimap2 algorithm with adjusting some hyperparameters that this algorithm allows us
to change to speed it up. For this solution, to be usable, we need to take only
a shorter part of squiggle and from the start of it. With signal from the $5\,000$th
readout to the $10\,000$th we have been able to find only the 31 out of 100 squiggles
in around 1 minute.

\section{Building the Index}

Results from the Chapter \ref{kap:proposedMethod} and Section \ref{section:alignMinimap}
encouraged us that it is possible to build the reasonable index over the reference
DNA sequence. We will proceed by building the index in the form of the big hashtable
that stores all the k-mers that are present in the reference simulated level string.
We now choose one individual contig from the reference DNA sequence and we create.

Lorem ipsum \ref{obr:kmerCoverage}.

\begin{figure}
\centerline{\includegraphics[width=1.0\textwidth, height=0.45\textheight]{images/kmerCoverage}}
\caption[TODO]{TODO}
\label{obr:kmerCoverage}
\end{figure}
