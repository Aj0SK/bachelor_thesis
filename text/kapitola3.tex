\chapter{Towards Building a Squiggle Index}

\label{kap:methAdjust} % id kapitoly pre prikaz ref

In this chapter, we use the results from the previous chapter and try to use our
discretization algorithm and findings to reach our goal of selective sequencing.
We will focus on finding the real squiggle in our reference. Now, we can use our
discretization method to help us with this task.

\section{Index idea}

We can transform the reference DNA sequence to signal using our simulation
process, choose the size of the window - $w$, create the level string of the reference.
Then, when the real signal from the squiggle arrives, we will perform the same process
as with the simulated reference signal. Now, we have one reference level string and
one which we want to find in it. We see that this can be better formulated as an
algorithmic problem. However, there is a minimal probability that the level string
of the longer squiggle would match precisely to some area in the reference level string.
Instead of looking for the exact match in the reference, we will cut the reference
level string into overlapping subsequences of length $k$ and put them into a hash table.
Hash table is a data structure that allows insertion and search of an element in
amortized time complexity $O(1)$. When we have this hash table ready after the
preprocessing, we can start with the actual squiggle processing. For every squiggle, we will
build the level string. Then, we will cut it into the overlapping
subsequences of the same length $k$ and see how many of them can be found in our
prepared hashtable. We call all the subsequences from our query squiggle that are
present in the hash table \textit{hits}. Our initial assumption is that the number
of hits will be considerably higher for the squiggle that belongs to the reference.

The important thing is that we need to use only the shortest possible part of the squiggle
and also use only the readouts from the beginning of the squiggle. Before tackling
this way harder problem, we will look at an easier task. We would want to see how
our discretization suits this usage and how similar is level string of the whole squiggle
comparing it to the reference level string. For this purpose, we will try to
find our query level string in the reference level string.

\section{Aligning the squiggle level string}
\label{section:alignMinimap}

We already know that it does not make sense to look for the exact match of the query string in the reference
so we will need some string searching technique that can deal with few errors.
Our alignment algorithm presented in Section \ref{section:alignment} could be adapted but it lacks the neccessary speed. This
algorithm works in the time complexity $O(r\cdot s)$ where $r$ is the length of the
reference sequence and $q$ is the length of the query string. Many algorithms are able
to do this fast and with very high accuracy. We decided to tweak a Minimap2 \cite{li2018minimap2} algorithm. This is
one of the most popular DNA sequence aligning algorithms. This algorithm can take the
query DNA sequence and find it in a long reference DNA sequence. It is also able to
find the query DNA string even if it does not exactly match any subsequence precisely.
Hovewer, this algorithm works only with the DNA sequences. What we will do is that we choose
the number of levels $w=4$. This will cause that the reference and query level strings will both consist of
the characters 'a', 'b', 'c', 'd'. We then substitute 'a', 'b', 'c', 'd' by
'A', 'C', 'G', 'T' subsequently. We now obtained the manipulated level strings that
are represented using the DNA sequences. Now, we can use the Minimap2 algorithm for
finding our manipulated query level string in the manipulated reference level string.
As the Minimap2 is most of the time used and also optimized to perform well on DNA
sequences, we need to be careful of some catches that come with using it for this
purpose. For example, we need to ignore the hits on the reverse strand as the
reverse strand does not carry the same information as in the real DNA sequence.
This also speeds up the whole algorithm considerably.

We now take the level string of the relatively big part of the squiggle. We take the
fixed part of the squiggle from the $5\,000$th readout to the $60\,000$th. Of the 50
tested squiggles, all of them were correctly aligned to the correct contig and also
correct position. This was a very promising result, so we decided to optimize a
Minimap2 algorithm with adjusting some hyperparameters that this algorithm allows us
to change to speed it up. For this solution, to be usable, we need to take only
a shorter part of squiggle and from the start of it. With signal from the $5\,000$th
readout to the $10\,000$th we have been able to find only the 31 out of 100 squiggles
in around 1 minute.

\section{Building the Index}

Results from the Chapter \ref{kap:proposedMethod} and Section \ref{section:alignMinimap}
encouraged us that it is possible to build the reasonable index over the reference
DNA sequence. We will proceed by building the index in the form of the hashtable
that stores all the $k$-mers that are present in the reference simulated level string.

We now choose two individual contigs from the reference DNA sequence.

After looking at our index, we can see that some of the $k$-mers have very big
number of occurences in the indexed reference level string. We suspect that these
$k$-mers are not that informative because they are very common and they carry more
information about the specific properties of the level string rather than information
about the underlying signal. In Figure \ref{obr:kmerCoverage} we look at what part of the
reference is covered by the $k$-mers up to the certain multiplicity.

\begin{figure}
\centerline{\includegraphics[width=1.0\textwidth, height=0.45\textheight]{images/kmerCoverage}}
\caption[TODO]{the percentage of the reference covered by the $k$-mers up to specific multiplicity
denoted on the x-axis}
\label{obr:kmerCoverage}
\end{figure}


The second approach that we tried is similar to how the alignment algorithms like
Minimap2 work. The first approach of these algorithms is to find the pairs of the shorter
exactly matching sequences. These are then used as the kernels of the alignment. We want
to use kernels as the starting points, to see where are the places that could lead to the
successful matching of the query level strings.

In order to try this approach we need to know what is the ideal length of this short
sequence. We need to find the maximum length of the $k$ for the particular level
such that level string from most of the squiggles will have at least one $k$-mer
of this length common with their corresponding simulated reference level string.
So we run the experiment on the data used in the previous experiments in Section
\ref{section:results}. Now, instead of working with the signal of the length
$5\,000$ we will work with the smaller number of $2\,000$ readouts so we
simulate the conditions during the real DNA sequencing. In the table \ref{tab:sharedKmers}
we can see the number of the squiggles with at least one shared $k$-mer with their reference
level string. We bring the values for the multiple levels. Based on this table,
we can expect what length of $k$-mer for the particular number of levels will be located
in the reference at least one time. We want to find the good tradeof between number of
squiggles that we will be able to find and the length of the $k$-mer which determines
the number of hits in the index we have to investigate.

\begin{table}
% v tabulke sa popis zvykne davat nad tabulku
\caption[TODO]{The number of squiggles with the at least 1 one shared $k$-mer with their
reference for particular number of levels}
%id tabulky
\label{tab:sharedKmers}
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
\hline
level number & \multicolumn{10}{|c|}{$k$-mer lengths} \\
\hline
4 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 & 25 \\\cline{2-11}
& 200 & 199 & 198 & 196 & 195 & 186 & 180 & 174 & 163 & 148 \\\cline{2-11}
\hline
5 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 & 25 & 26 \\\cline{2-11}
& 200 & 199 & 199 & 197 & 190 & 184 & 176 & 163 & 158 & 148 \\\cline{2-11}
\hline
7 & 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 & 24 \\\cline{2-11}
& 200 & 199 & 198 & 195 & 183 & 167 & 157 & 132 & 119 & 100 \\\cline{2-11}
\hline
9 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 \\\cline{2-11}
& 200 & 199 & 191 & 184 & 160 & 134 & 108 & 86 & 71 & 49 \\\cline{2-11}
\hline
11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\cline{2-11}
& 200 & 199 & 192 & 175 & 153 & 124 & 95 & 72 & 54 & 41 \\\cline{2-11}
\hline
13 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 \\\cline{2-11}
& 200 & 196 & 190 & 176 & 152 & 122 & 82 & 63 & 44 & 28 \\\cline{2-11}
\hline
\end{tabular}
\end{center}
\end{table}

Now, when we have for all the levels the particular number of $k$ that
has the minimal number of hits for most of the reads we can proceed to use
this information.
