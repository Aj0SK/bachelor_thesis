\chapter{Squiggle Discretization and Similarity Between Squiggles}

\label{kap:proposedMethod} % id kapitoly pre prikaz ref

In this chapter, we will present our proposed solution.

\section{Squiggles as Sequencing of Discrete Observations}

We want to create a fast yet accurate solution. The idea of our solution is to somehow
discretize the simulated signal of the reference sequence and then be able to decide
during the process of sequencing if the DNA molecule currently passing through the
pore is from this reference signal. In our current setup, we are not very limited
by the preprocessing time but we need to decide very fast once we are sequencing
the DNA. This puts some speed limitations on our discretizing process during the
processing of the DNA.

It's good for us to represent the signal visually as a graph. To a certain extent, we
can see that the two signals are similar. However, we need to do this fast and on very
long signals. The main goal is to be able to find the signal in the reference
signal if it is present. This is only possible if we somehow represent the signal
in a more compact form in some searchable way. What we will do is that we will
represent the signal as a string. What we will do is that we split the signal vertically
into several windows in such a manner that everything between minimal and maximal
signal is in some window. These windows are for now of constant length and do not
overlap. More formally, let $a_i$ be the signal at the time $i$, $m$ the number of
vertical windows. Now, when we have some signal $s$ of length $n$, $s=a_1a_2a_3\cdots a_n$.
Besides this, we have some values $min_a$, $max_a$ that $\forall a_i: min_a \leq a_i < max_a$. We say that signal $a_i$ is in $j$-th
window if it holds that:

\begin{center}
$min_a + j\cdot \frac{max_a-min_a}{m} \leq a_i < min_a + (j+1)\cdot \frac{max_a-min_a}{m}$
\end{center}

% TODO obrazok

An example of this method on some signal for $w=6$ is on TODO. This method has several good
properties that we use. The first and obvious property is that the same signal has the
same level string each time for the unchanged $w$. Besides this, small changes and
oscillations in the signal will eventually stay at the same level most of the time.
Another good factor is that with the change of the parameter $w$ we can change how specific
and informative our method is. With the $w=2$ we can not say a lot about the two signals
that have level string equal. With bigger $w$ we can miss the two same signals
if there is a little noise present. We also mentioned the different lengths of
the real and simulated signal. To offset even this negative phenomenon, we will contract
subsequent occurrences of the same level. So level string "aabccaa" becomes "abca".

So now, we can transform the reference DNA sequence to signal using our simulation
process, choose the size of the window - $w$, create the level string of the reference.
Then, when the real signal from the read arrives, we will perform the same process
as with the simulated reference signal. Now we have one reference level string and
one which we want to find in it. We see that this can be better formulated as an
algorithmic problem. However, there is a very small probability that the level string
of the longer read would match exactly to some area in the reference level string.
Instead of looking for the exact match in the reference we will cut the reference
level string into overlapping subsequences of length $k$ and put them into a hashtable.
Hash table is a data structure that allows insertion and search of an element in
amortized time complexity $O(1)$. When we have this hashtable ready after the
preprocessing we can start with the actual read processing. For every read, we will
build the level string from the raw signal. Then, we will cut it into the overlapping
subsequences of the same length $k$ and see how many of them can be found in our
prepared hashtable. We call all the subsequences that are present in the hashtable
hits. Our initial assumption is that the number of hits will be considerably higher
for the read belonging to the reference.

\section{Simulating Squiggles from Reference}

We already stated that we need to obtain some reference signal that we
can sample and use to later split reads between that we are interested in and not
interested in. For this purpose, we need to take the reference in the form of a DNA sequence
and turn it into a signal. We will use the nanopore data
variant caller (nadavca) which is a tool that can take a DNA sequence as an input
and produce a simulated signal. This simulation does not take into account that
the signal from one nucleotide is measured several times. We already estimated
that one nucleotide is on average measured about 10 times so we will duplicate every
entry in this simulated signal 10 times. We want to see how this signal compares
to real signal so to put these two into perspective we normalize this signal by
subtracting mean and removing standard deviation \ref{obr:simVsReal}.

\begin{figure}
\centerline{\includegraphics[width=0.7\textwidth, height=0.3\textheight]{images/simulateRef}}
\caption[Hehe]{Simulated signal vs real signal}
\label{obr:simVsReal}
\end{figure}

% https://github.com/lykaust15/DeepSimulator
There are some more advanced simulators of signal such as DeepSimulator but we
wanted to begin with the simplest possible solution.

\section{Real and simulated signal comparison}

Now we have a simulated reference signal. We can see that the simulated and real
signal are not identical in \ref{obr:simVsReal}. This poses problems as we want to have these signals as
similar as possible. The first thing that we want to consider is normalization. There
are two possible approaches, local and global normalization. We will try both these
approaches. One of the most wide-spread ways of doing this is to subtract mean and dividing
signal by standard deviation. The other possible solution is subtracting median value
as the frequent outliers can deform the mean. 

Another visible problem is that the real signal is somehow contracted
in some places. This is caused by the fact that the DNA molecule is not moving
through the pore at a constant speed. 

\section{Oscillations}

We already saw in TODO that one of the biggest differences between simulated and
real signal is the noise which can be seen as small oscillations of the signal. This is
one of the reasons that we use windows - so small oscillations within the window
are dealt with. However, when our method is used without any modifications it
produces much longer level string for real signal than for simulated signal.
The problem arises when the oscillations are located on the borders of the windows.
There are several possibilities to deal with this behavior not affecting speed too
much. We tried several smoothing algorithms to reduce noise. From simple as the
moving average and the moving median to some more complicated as a kalman filter.
For now, we will stick to the faster solutions and choose one of the simpler techniques.

\section{Signal continuity}

The next difference that was visible from the comparison of real signal level string
and the simulated signal level string is that the real signal is more continuous instead
of a simulated signal that jumps. Again, we can use the moving average. Instead of
the moving median, it has a nice advantage that it causes signal not to jump from
one level to another but rather move continuously.
